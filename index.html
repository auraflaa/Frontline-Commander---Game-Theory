<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frontline Commander - Sequential Blotto</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Framer Motion -->
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -9px; 
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            border: 2px solid #3b82f6;
        }
        input[type=range]::-moz-range-thumb {
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: 2px solid #3b82f6;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: transparent;
        }
        
        /* Scrollbar for details modal */
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>
<body class="bg-slate-950 text-slate-200 overflow-hidden selection:bg-blue-500 selection:text-white">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;
        const { motion, AnimatePresence } = window.Motion;

        // ==========================================
        // ðŸ”‘ API CONFIGURATION
        // ==========================================
        
        const X_API_KEY = "X_API_KEY"; 

        const VOICE_IDS = {
            TYRANT: "tc_634f8ecab302fd064cd4c20f", // Warlord
            HARD: "tc_634f8ecab302fd064cd4c20f", // Warlord
            EASY: "tc_634f8ed3165554e4256eedac", // Rookie
            MEDIUM: "tc_632a757ae7c78a412f5a36c0" // Tactician
        };

        const voiceCache = new Map();

        // ==========================================

        // --- GLOBAL AUDIO CONTEXT MANAGER ---
        let sharedAudioCtx = null;

        const getAudioContext = () => {
            if (!sharedAudioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    sharedAudioCtx = new AudioContext();
                }
            }
            if (sharedAudioCtx && sharedAudioCtx.state === 'suspended') {
                sharedAudioCtx.resume().catch(e => console.log("Audio resume failed", e));
            }
            return sharedAudioCtx;
        };

        // --- RPG VOICE ENGINE (BACKUP/UI SOUNDS) ---
        const playVoiceTone = (difficulty) => {
            if (X_API_KEY && X_API_KEY !== "X_API_KEY") return;

            try {
                const ctx = getAudioContext();
                if (!ctx) return;
                
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);

                if (difficulty === 'EASY') {
                    osc.type = 'triangle';
                    const baseFreq = 600 + (Math.random() * 150 - 75); 
                    osc.frequency.setValueAtTime(baseFreq, now);
                    osc.frequency.linearRampToValueAtTime(baseFreq - 50, now + 0.08);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                    osc.start(now);
                    osc.stop(now + 0.08);
                } else if (difficulty === 'MEDIUM') {
                    osc.type = 'square';
                    const baseFreq = 220; 
                    osc.frequency.setValueAtTime(baseFreq, now);
                    gain.gain.setValueAtTime(0.04, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                    osc.start(now);
                    osc.stop(now + 0.05);
                } else if (difficulty === 'HARD' || difficulty === 'TYRANT') {
                    osc.type = 'sawtooth';
                    const baseFreq = 70 + (Math.random() * 10); 
                    osc.frequency.setValueAtTime(baseFreq, now);
                    gain.gain.setValueAtTime(0.08, now);
                    gain.gain.linearRampToValueAtTime(0.001, now + 0.12); 
                    osc.start(now);
                    osc.stop(now + 0.12);
                }
            } catch (e) {}
        };

        // --- SFX ENGINE ---
        const playInterfaceSound = (type = 'click') => {
            try {
                const ctx = getAudioContext();
                if (!ctx) return;
                const now = ctx.currentTime;

                const createNoiseBuffer = () => {
                    const bufferSize = ctx.sampleRate * 2;
                    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
                    return buffer;
                };

                switch (type) {
                    case 'click':
                        const oscClick = ctx.createOscillator();
                        const gainClick = ctx.createGain();
                        oscClick.type = 'sine';
                        oscClick.frequency.setValueAtTime(800, now);
                        oscClick.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
                        gainClick.gain.setValueAtTime(0.05, now);
                        gainClick.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                        oscClick.connect(gainClick);
                        gainClick.connect(ctx.destination);
                        oscClick.start(now);
                        oscClick.stop(now + 0.05);
                        break;
                    case 'lock':
                        const oscLock = ctx.createOscillator();
                        const gainLock = ctx.createGain();
                        oscLock.type = 'square';
                        oscLock.frequency.setValueAtTime(150, now);
                        oscLock.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                        gainLock.gain.setValueAtTime(0.1, now);
                        gainLock.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                        oscLock.connect(gainLock);
                        gainLock.connect(ctx.destination);
                        oscLock.start(now);
                        oscLock.stop(now + 0.2);
                        break;
                    case 'spin-tick':
                        const oscTick = ctx.createOscillator();
                        const gainTick = ctx.createGain();
                        oscTick.type = 'triangle';
                        oscTick.frequency.setValueAtTime(800, now); 
                        oscTick.frequency.exponentialRampToValueAtTime(300, now + 0.05);
                        gainTick.gain.setValueAtTime(0.05, now);
                        gainTick.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                        oscTick.connect(gainTick);
                        gainTick.connect(ctx.destination);
                        oscTick.start(now);
                        oscTick.stop(now + 0.05);
                        break;
                    
                    case 'select-easy':
                        const oscEasy = ctx.createOscillator();
                        const gainEasy = ctx.createGain();
                        oscEasy.type = 'sine';
                        oscEasy.frequency.setValueAtTime(400, now);
                        oscEasy.frequency.linearRampToValueAtTime(600, now + 0.1);
                        gainEasy.gain.setValueAtTime(0.1, now);
                        gainEasy.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                        oscEasy.connect(gainEasy);
                        gainEasy.connect(ctx.destination);
                        oscEasy.start(now);
                        oscEasy.stop(now + 0.3);
                        break;
                    case 'select-medium':
                        const oscMed = ctx.createOscillator();
                        const gainMed = ctx.createGain();
                        oscMed.type = 'sawtooth';
                        oscMed.frequency.setValueAtTime(200, now);
                        oscMed.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                        gainMed.gain.setValueAtTime(0.1, now);
                        gainMed.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                        oscMed.connect(gainMed);
                        gainMed.connect(ctx.destination);
                        oscMed.start(now);
                        oscMed.stop(now + 0.15);
                        break;
                    case 'select-hard':
                    case 'select-tyrant':
                        const oscHard1 = ctx.createOscillator();
                        const oscHard2 = ctx.createOscillator();
                        const gainHard = ctx.createGain();
                        oscHard1.type = 'sawtooth';
                        oscHard2.type = 'square';
                        oscHard1.frequency.setValueAtTime(60, now);
                        oscHard1.frequency.linearRampToValueAtTime(40, now + 0.5);
                        oscHard2.frequency.setValueAtTime(58, now);
                        oscHard2.frequency.linearRampToValueAtTime(38, now + 0.5);
                        gainHard.gain.setValueAtTime(0.2, now);
                        gainHard.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                        oscHard1.connect(gainHard);
                        oscHard2.connect(gainHard);
                        gainHard.connect(ctx.destination);
                        oscHard1.start(now);
                        oscHard2.start(now);
                        oscHard1.stop(now + 0.8);
                        oscHard2.stop(now + 0.8);
                        break;

                    case 'clash':
                        const noise = ctx.createBufferSource();
                        noise.buffer = createNoiseBuffer();
                        const noiseFilter = ctx.createBiquadFilter();
                        noiseFilter.type = 'bandpass';
                        noiseFilter.frequency.value = 3000; 
                        const noiseGain = ctx.createGain();
                        noiseGain.gain.setValueAtTime(0.2, now);
                        noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                        noise.connect(noiseFilter);
                        noiseFilter.connect(noiseGain);
                        noiseGain.connect(ctx.destination);
                        noise.start(now);
                        noise.stop(now + 0.4);
                        break;
                    case 'win':
                        [0, 0.15, 0.3].forEach((delay, i) => {
                            const osc = ctx.createOscillator();
                            const g = ctx.createGain();
                            osc.type = 'triangle';
                            const freq = [523.25, 659.25, 783.99][i];
                            osc.frequency.setValueAtTime(freq, now + delay);
                            g.gain.setValueAtTime(0.1, now + delay);
                            g.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.8);
                            osc.connect(g);
                            g.connect(ctx.destination);
                            osc.start(now + delay);
                            osc.stop(now + delay + 0.8);
                        });
                        break;
                    case 'lose':
                        [0, 0.2].forEach((delay, i) => {
                            const osc = ctx.createOscillator();
                            const g = ctx.createGain();
                            osc.type = 'sawtooth';
                            const freq = [100, 70][i];
                            osc.frequency.setValueAtTime(freq, now + delay);
                            osc.frequency.linearRampToValueAtTime(freq - 20, now + delay + 0.6);
                            g.gain.setValueAtTime(0.1, now + delay);
                            g.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.9);
                            osc.connect(g);
                            g.connect(ctx.destination);
                            osc.start(now + delay);
                            osc.stop(now + delay + 0.9);
                        });
                        break;
                    case 'march':
                        const oscMarch = ctx.createOscillator();
                        const gainMarch = ctx.createGain();
                        oscMarch.type = 'sine';
                        oscMarch.frequency.setValueAtTime(80, now);
                        oscMarch.frequency.exponentialRampToValueAtTime(0.01, now + 0.2);
                        gainMarch.gain.setValueAtTime(0.3, now);
                        gainMarch.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                        oscMarch.connect(gainMarch);
                        gainMarch.connect(ctx.destination);
                        oscMarch.start(now);
                        oscMarch.stop(now + 0.2);
                        break;
                }
            } catch (e) {}
        };

        // --- REAL VOICE API & FALLBACK ENGINE ---
        const speakText = async (text, difficulty, voiceBank) => {
            const cacheKey = `${difficulty}-${text}`;
            
            // 1. CHECK CACHE
            if (voiceCache.has(cacheKey)) {
                const audio = new Audio(voiceCache.get(cacheKey));
                audio.play();
                return;
            }

            // 2. TRY TYPECAST API
            if (X_API_KEY && X_API_KEY !== "X_API_KEY") {
                try {
                    const voiceId = VOICE_IDS[difficulty] || VOICE_IDS.HARD;
                    
                    const response = await fetch('https://api.typecast.ai/v1/text-to-speech', { 
                        method: 'POST',
                        headers: {
                            'X-API-KEY': X_API_KEY,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            voice_id: voiceId,
                            text: text,
                            model: "ssfm-v21",
                            language: "eng",
                            prompt: { emotion_preset: "normal", emotion_intensity: 1 },
                            output: { volume: 100, audio_pitch: 0, audio_tempo: 1, audio_format: "wav" },
                            seed: 42
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        
                        if (data.result && data.result.audio_download_url) {
                            const audioUrl = data.result.audio_download_url;
                            voiceCache.set(cacheKey, audioUrl);
                            new Audio(audioUrl).play();
                            return;
                        } else if (data.result && data.result.speak_url) {
                            // POLL for audio if it's being generated
                            const pollUrl = data.result.speak_url;
                            let attempts = 0;
                            
                            const poll = async () => {
                                if (attempts > 5) return; // Timeout
                                const pollRes = await fetch(pollUrl, {
                                     headers: { 'X-API-KEY': X_API_KEY }
                                });
                                const pollData = await pollRes.json();
                                if (pollData.result && pollData.result.audio_download_url) {
                                    const finalUrl = pollData.result.audio_download_url;
                                    voiceCache.set(cacheKey, finalUrl);
                                    new Audio(finalUrl).play();
                                } else {
                                    attempts++;
                                    setTimeout(poll, 1000); // Wait 1s
                                }
                            };
                            poll();
                            return;
                        }
                    } 
                } catch (e) {
                    console.warn("Voice API failed, using fallback");
                }
            }

            // 3. FALLBACK TO BROWSER TTS (Improved Consistency)
            if (!window.speechSynthesis) return;
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            
            // Use pre-selected voice from bank
            if (voiceBank && voiceBank[difficulty]) {
                utterance.voice = voiceBank[difficulty];
            }

            // Specific Tuning for Fallback to match Persona
            if (difficulty === 'EASY') {
                utterance.pitch = 1.2; 
                utterance.rate = 1.1; 
            } else if (difficulty === 'MEDIUM') {
                utterance.pitch = 1.0; 
                utterance.rate = 1.0;
            } else if (difficulty === 'HARD' || difficulty === 'TYRANT') {
                utterance.pitch = 0.7; 
                utterance.rate = 0.9;
            }

            window.speechSynthesis.speak(utterance);
        };

        // --- TYPEWRITER COMPONENT ---
        const TypewriterLog = ({ text, difficulty, className }) => {
            const [displayedText, setDisplayedText] = useState('');
            const indexRef = useRef(0);
            const shouldUseRpgBeeps = !X_API_KEY || X_API_KEY === "X_API_KEY";

            useEffect(() => {
                setDisplayedText('');
                indexRef.current = 0;
                if (!text) return;

                const intervalId = setInterval(() => {
                    if (indexRef.current < text.length) {
                        setDisplayedText((prev) => prev + text.charAt(indexRef.current));
                        if (shouldUseRpgBeeps && indexRef.current % 2 === 0 && text.charAt(indexRef.current) !== ' ') {
                            playVoiceTone(difficulty);
                        }
                        indexRef.current++;
                    } else {
                        clearInterval(intervalId);
                    }
                }, 40); 

                return () => clearInterval(intervalId);
            }, [text, difficulty, shouldUseRpgBeeps]);

            return (
                <div className={className}>{displayedText}</div>
            );
        };

        // --- BADGE COMPONENTS ---
        const BadgeRookie = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" className={className}><path d="M12 2L3 7v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-9-5z" fill="currentColor" fillOpacity="0.1"/><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/><path d="M12 8v8" strokeWidth="2.5"/><path d="M8 12l4-4 4 4" strokeWidth="2.5"/></svg>);
        const BadgeTactician = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" className={className}><circle cx="12" cy="12" r="10" className="opacity-20" fill="currentColor"/><circle cx="12" cy="12" r="10" /><circle cx="12" cy="12" r="6" /><circle cx="12" cy="12" r="2" fill="currentColor"/><line x1="12" y1="2" x2="12" y2="22" /><line x1="2" y1="12" x2="22" y2="12" /><path d="M17 7l-5 5" /></svg>);
        const BadgeWarlord = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" className={className}><path d="M17 16l3-1v-4l-4-3-3 2-2-5-2 5-3-2-4 3v4l3 1" fill="currentColor" fillOpacity="0.2"/><path d="M12 2l2 5 3 2 4-3v4l-3 1v5c0 3-4 6-6 6s-6-3-6-6v-5l-3-1v-4l4 3 3-2 2-5z" strokeWidth="2"/><path d="M9 14l1 2" /><path d="M14 16l1-2" /><path d="M9 10h.01" strokeWidth="3"/><path d="M15 10h.01" strokeWidth="3"/></svg>);
        const BadgeTyrant = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" className={className}><path d="M2 4l3 12h14l3-12-6 7-4-7-4 7-6-7zm3 16h14v2H5z" fill="currentColor" fillOpacity="0.2"/><path d="M2 4l3 12h14l3-12-6 7-4-7-4 7-6-7z" strokeWidth="2"/><circle cx="12" cy="6" r="2" /></svg>);

        // --- ICONS ---
        const IconUser = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>);
        const DetailedCastle = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path d="M2 22H22V13H20V10H18V13H16V10H14V13H10V10H8V13H6V10H4V13H2V22ZM4 15H6V17H4V15ZM8 15H10V17H8V15ZM14 15H16V17H14V15ZM18 15H20V17H18V15ZM7 2H5V8H7V2ZM11 2H9V8H11V2ZM15 2H13V8H15V2ZM19 2H17V8H19V2ZM10 19H14V22H10V19Z" stroke="currentColor" strokeWidth="0.5"/></svg>);
        const IconShield = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>);
        const IconSword = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="14.5 17.5 3 6 3 3 6 3 17.5 14.5"/><line x1="13" y1="19" x2="19" y2="13"/><line x1="16" y1="16" x2="20" y2="20"/><line x1="19" y1="21" x2="21" y2="19"/></svg>);
        const IconTrophy = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>);
        const IconSun = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="5"/><path d="M12 1v2"/><path d="M12 21v2"/><path d="M4.22 4.22l1.42 1.42"/><path d="M18.36 18.36l1.42 1.42"/><path d="M1 12h2"/><path d="M21 12h2"/><path d="M4.22 19.78l1.42-1.42"/><path d="M18.36 5.64l1.42-1.42"/></svg>);
        const IconMoon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>);
        const IconPlus = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>);
        const IconMinus = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="5" y1="12" x2="19" y2="12"></line></svg>);
        const IconCpu = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="4" y="4" width="16" height="16" rx="2"/><rect x="9" y="9" width="6" height="6"/><path d="M9 1v3"/><path d="M15 1v3"/><path d="M9 20v3"/><path d="M15 20v3"/><path d="M20 9h3"/><path d="M20 14h3"/><path d="M1 9h3"/><path d="M1 14h3"/></svg>
        );
        const IconInfo = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
        );

        // --- DATA: PERSONAS & DIALOGUE ---
        const PERSONAS = {
            EASY: {
                name: "THE ROOKIE",
                icon: BadgeRookie,
                description: "Nervous. Hesitant. Vulnerable.",
                dialogues: {
                    userWin: ["Gah! Too many!", "Retreat! I miscalculated!", "Ouch! Unfair!", "You're too strong!"],
                    botWin: ["Wait, I won? Nice!", "Beginner's luck!", "Target neutralized!", "I did it! I actually did it!"],
                    tie: ["A draw? I'll take it.", "Phew, that was close.", "Nobody moves!"]
                },
                taglines: {
                    userWin: "Back to boot camp for me...",
                    botWin: "Beginner's luck? No way, I'm a genius!",
                    tie: "Hey, at least I didn't lose!"
                }
            },
            MEDIUM: {
                name: "THE TACTICIAN",
                icon: BadgeTactician,
                description: "Calculated. Efficient. Balanced.",
                dialogues: {
                    userWin: ["Well played, Commander.", "Significant commitment.", "Acceptable losses. Adjusting.", "A costly victory for you."],
                    botWin: ["Predictable maneuver.", "Execution: Optimal.", "Your resources are inefficient.", "Tactical superiority established."],
                    tie: ["Matched evenly. Interesting.", "Our estimates were identical.", "A standstill."]
                },
                taglines: {
                    userWin: "A superior strategy. Well fought, Commander.",
                    botWin: "Efficiency is the key to victory.",
                    tie: "A perfect equilibrium. Fascinating."
                }
            },
            HARD: {
                name: "THE WARLORD",
                icon: BadgeWarlord,
                description: "Ruthless. Omniscient. Brutal.",
                dialogues: {
                    userWin: ["A fleeting victory.", "You waste resources like a child.", "You bleed for this?", "Enjoy your scrap of land."],
                    botWin: ["Pathetic. Try harder.", "I own this battlefield.", "Crushed beneath my heel.", "Too easy. Is this your best?"],
                    tie: ["You delay the inevitable.", "Fight harder.", "Deadlock. Disappointing."]
                },
                taglines: {
                    userWin: "Impossible... You have merely delayed the inevitable.",
                    botWin: "Weakness is a disease. I am the cure.",
                    tie: "A stalemate is just a pause in the slaughter."
                }
            },
            TYRANT: {
                name: "THE TYRANT",
                icon: BadgeTyrant,
                description: "Unfair. Overwhelming. Asymmetric.",
                dialogues: {
                    userWin: ["You bought that victory with blood.", "A minor setback.", "Enjoy it while it lasts, peasant.", "Insignificant loss."],
                    botWin: ["Crushed by superior numbers.", "My armies are endless.", "Did you really think you could win?", "Submit to my rule."],
                    tie: ["A stalemate? With your tiny army? Impressive.", "You merely delayed your doom.", "I have more where those came from."]
                },
                taglines: {
                    userWin: "This... this is an error in the matrix! Inconceivable!",
                    botWin: "Drown in the tide of my legions.",
                    tie: "You survived? Mere luck."
                }
            }
        };

        // --- REUSABLE COMPONENTS ---
        const ConfigControl = ({ label, value, min, max, step, onChange, isDark }) => {
            const [particles, setParticles] = useState([]);
            const handleAdjust = (direction) => {
                const newValue = value + (direction * step);
                if (newValue >= min && newValue <= max) {
                    onChange(newValue);
                    playInterfaceSound('click');
                    const id = Date.now();
                    const text = direction > 0 ? `+${step}` : `-${step}`;
                    setParticles(prev => [...prev, { id, text, direction }]);
                    setTimeout(() => { setParticles(prev => prev.filter(p => p.id !== id)); }, 800);
                }
            };
            const textSecondary = isDark ? "text-slate-500" : "text-slate-500";
            const btnClass = isDark 
                ? "bg-slate-800 hover:bg-slate-700 text-blue-400 border-slate-700" 
                : "bg-white hover:bg-slate-50 text-blue-600 border-slate-200 shadow-sm";

            return (
                <div className="mb-8">
                    <div className="flex justify-between items-end mb-3">
                        <label className={`text-sm font-bold tracking-wide ${textSecondary}`}>{label}</label>
                        <div className="relative">
                            <span className="text-blue-500 font-mono text-2xl font-bold">{value}</span>
                            <AnimatePresence>
                                {particles.map(p => (
                                    <motion.div key={p.id} initial={{ opacity: 1, y: 0, x: 20 }} animate={{ opacity: 0, y: -20 }} exit={{ opacity: 0 }} className={`absolute right-0 top-0 text-sm font-bold ${p.direction > 0 ? 'text-green-500' : 'text-red-500'}`}>
                                        {p.text}
                                    </motion.div>
                                ))}
                            </AnimatePresence>
                        </div>
                    </div>
                    <div className="flex items-center gap-4">
                        <motion.button whileTap={{ scale: 0.9 }} onClick={() => handleAdjust(-1)} className={`w-8 h-8 flex items-center justify-center rounded-full border ${btnClass} transition-colors`}><IconMinus className="w-4 h-4" /></motion.button>
                        <div className="relative h-6 flex-1 flex items-center">
                            <input type="range" min={min} max={max} step={step} value={value} onChange={(e) => onChange(parseInt(e.target.value))} className="absolute z-30 w-full h-full opacity-0 cursor-pointer" />
                            <div className={`absolute z-10 w-full h-3 rounded-full border ${isDark ? 'bg-slate-950 border-slate-600' : 'bg-slate-300 border-slate-400'}`}></div>
                            <div className="absolute z-10 h-3 bg-blue-500 rounded-full pointer-events-none transition-all duration-100" style={{ width: `${(value - min) / (max - min) * 100}%` }}></div>
                            <div className="absolute z-20 h-6 w-6 bg-white border-2 border-blue-500 rounded-full shadow-lg transition-all duration-75" style={{ left: `calc(${((value - min) / (max - min) * 100)}% - 12px)` }}></div>
                        </div>
                        <motion.button whileTap={{ scale: 0.9 }} onClick={() => handleAdjust(1)} className={`w-8 h-8 flex items-center justify-center rounded-full border ${btnClass} transition-colors`}><IconPlus className="w-4 h-4" /></motion.button>
                    </div>
                </div>
            );
        };
        
        // --- DETAILS MODAL COMPONENT ---
        const DetailsModal = ({ onClose, isDark }) => {
            const bg = isDark ? "bg-slate-900 border-slate-700" : "bg-white border-slate-200";
            const textP = isDark ? "text-slate-200" : "text-slate-800";
            const textS = isDark ? "text-slate-400" : "text-slate-500";
            
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4" onClick={onClose}>
                    <motion.div 
                        initial={{ opacity: 0, scale: 0.9 }}
                        animate={{ opacity: 1, scale: 1 }}
                        className={`max-w-2xl w-full max-h-[80vh] overflow-y-auto p-8 rounded-2xl border shadow-2xl relative scrollbar-hide ${bg}`}
                        onClick={e => e.stopPropagation()}
                    >
                        <button onClick={onClose} className="absolute top-4 right-4 p-2 rounded-full hover:bg-gray-500/20">âœ•</button>
                        
                        <h2 className={`text-2xl font-black mb-4 ${textP}`}>INTELLIGENCE BRIEFING</h2>
                        
                        <section className="mb-6">
                            <h3 className="text-lg font-bold text-blue-500 mb-2">MISSION OBJECTIVE</h3>
                            <p className={`mb-2 ${textP}`}>This simulation is based on the <strong>Colonel Blotto</strong> game theory problem. Your goal is to win the majority of battlefields (Castles) by deploying your limited troops more effectively than your opponent.</p>
                            <ul className={`list-disc list-inside ${textS} space-y-1`}>
                                <li>Battles are sequential (one by one).</li>
                                <li>Troops used in a battle are gone forever.</li>
                                <li>You must manage your reserves for future fights.</li>
                            </ul>
                        </section>

                        <section className="mb-6">
                            <h3 className="text-lg font-bold text-red-500 mb-2">ENEMY PROFILES</h3>
                            <div className="space-y-3">
                                <div>
                                    <span className="font-bold text-green-500">THE ROOKIE:</span> <span className={textS}>Erratic and nervous. Often underbids or makes mistakes. Easy to bait.</span>
                                </div>
                                <div>
                                    <span className="font-bold text-blue-400">THE TACTICIAN:</span> <span className={textS}>Balanced and mathematical. Plays the "fair average" but adapts to your spending.</span>
                                </div>
                                <div>
                                    <span className="font-bold text-red-500">THE WARLORD:</span> <span className={textS}>Ruthless optimizer. Calculates opportunity cost. Will retreat to save troops and crush you later.</span>
                                </div>
                                <div>
                                    <span className="font-bold text-purple-500">THE TYRANT:</span> <span className={textS}>Unfair fight. Starts with +25% more troops. You cannot win a fair fight; you must outsmart him.</span>
                                </div>
                            </div>
                        </section>
                        
                        <div className={`text-xs text-center ${textS} mt-8 border-t border-gray-700 pt-4`}>
                            Frontline Commander v2.1 â€¢ Sequential Resource Allocation Sim
                        </div>
                    </motion.div>
                </div>
            );
        };

        // --- MAIN APP ---
        const FrontlineCommander = () => {
            const [gameState, setGameState] = useState('SETUP'); 
            const [configTroops, setConfigTroops] = useState(100);
            const [configCastles, setConfigCastles] = useState(5);
            const [difficulty, setDifficulty] = useState('MEDIUM');
            const [theme, setTheme] = useState('dark'); 
            const [voiceBank, setVoiceBank] = useState({ EASY: null, MEDIUM: null, HARD: null });
            const [showDetails, setShowDetails] = useState(false);

            const [userTroops, setUserTroops] = useState(100);
            const [botTroops, setBotTroops] = useState(100);
            const [castles, setCastles] = useState([]);
            
            const [activeCastleId, setActiveCastleId] = useState(null);
            const [highlightedCastleId, setHighlightedCastleId] = useState(null);
            const [currentBid, setCurrentBid] = useState(0);
            const [battleLog, setBattleLog] = useState("");

            // RESTORED: VOICE LOADING HOOK
            useEffect(() => {
                const initVoices = () => {
                    const voices = window.speechSynthesis.getVoices();
                    if (voices.length === 0) return;

                    const findVoice = (names) => voices.find(v => names.some(n => v.name.includes(n))) || voices.find(v => v.lang.startsWith("en")) || voices[0];

                    setVoiceBank({
                        EASY: findVoice(["Google US English", "Samantha", "Microsoft Zira"]),
                        MEDIUM: findVoice(["Google UK English Male", "Daniel", "Microsoft David"]),
                        HARD: findVoice(["Google UK English Male", "Google US English", "Microsoft Mark"]),
                        TYRANT: findVoice(["Google UK English Male", "Microsoft Mark"]) // Reuse heavy voice
                    });
                };
                
                initVoices();
                if (window.speechSynthesis.onvoiceschanged !== undefined) {
                    window.speechSynthesis.onvoiceschanged = initVoices;
                }
            }, []);

            const toggleTheme = () => {
                playInterfaceSound('click');
                setTheme(prev => prev === 'dark' ? 'light' : 'dark');
            };
            const isDark = theme === 'dark';

            const selectDifficulty = (level) => {
                const soundType = level === 'EASY' ? 'select-easy' : level === 'MEDIUM' ? 'select-medium' : 'select-hard';
                playInterfaceSound(soundType);
                setDifficulty(level);
            };

            const getRandomDialogue = (result) => {
                const persona = PERSONAS[difficulty];
                const type = result === 'user' ? 'userWin' : result === 'bot' ? 'botWin' : 'tie';
                const options = persona.dialogues[type];
                return options[Math.floor(Math.random() * options.length)];
            };

            const startGame = () => {
                playInterfaceSound('lock');
                setUserTroops(configTroops);
                let initialBotTroops = configTroops;
                if (difficulty === 'TYRANT') {
                    initialBotTroops = Math.floor(configTroops * 1.25);
                }
                setBotTroops(initialBotTroops);
                setCastles(
                    Array.from({ length: configCastles }, (_, i) => ({ id: i, status: 'pending', userBid: 0, botBid: 0 }))
                );
                const persona = PERSONAS[difficulty];
                setBattleLog(`UPLINK ESTABLISHED: ${persona.name} DETECTED.`);
                setGameState('START');
            };

            const resetToSetup = () => {
                playInterfaceSound('click');
                setGameState('SETUP');
            };

            const calculateBotBid = () => {
                const pendingCount = castles.filter(c => c.status === 'pending').length;
                if (pendingCount === 0) return 0;
                
                const userAvg = userTroops / pendingCount;

                if (difficulty === 'EASY') {
                    if (Math.random() < 0.2) return 1; 
                    let bid = Math.floor(userAvg * (0.6 + Math.random())); 
                    if (bid > botTroops) bid = botTroops;
                    return bid;
                }

                if (difficulty === 'MEDIUM') {
                   if (botTroops > userTroops + 15) return Math.floor(userAvg + 5);
                   if (userTroops > botTroops + 10) return Math.random() > 0.6 ? Math.floor(botTroops * 0.9) : 0;
                   let bid = Math.floor(userAvg * 1.1) + 1;
                   if (bid < 0) bid = 0;
                   if (bid > botTroops) bid = botTroops;
                   return bid;
                }

                if (difficulty === 'HARD') {
                    if (pendingCount <= 2) {
                        if (botTroops > userTroops) return Math.floor(botTroops / 2) + 1; 
                        return Math.floor(botTroops * 0.6); 
                    }
                    let idealBid = Math.floor(userAvg + 2);
                    const myFutureAvg = (botTroops - idealBid) / (pendingCount - 1);
                    const userFutureAvgIfTheyLose = (userTroops) / (pendingCount - 1); 
                    if (myFutureAvg < userFutureAvgIfTheyLose * 0.8) {
                         return Math.random() > 0.7 ? 1 : 0; 
                    }
                    if (botTroops > userTroops) return Math.floor(userAvg * 1.3);
                    return idealBid;
                }

                if (difficulty === 'TYRANT') {
                    let idealBid = Math.floor(userAvg * 1.25) + 1;
                    if (idealBid > botTroops) idealBid = botTroops;
                    return idealBid;
                }
                
                return 0;
            };

            const startRound = (customCastles = null) => {
                playInterfaceSound('click');
                setGameState('SPINNING');
                setBattleLog("ACQUIRING TARGET...");
                setCurrentBid(0);

                const currentCastles = Array.isArray(customCastles) ? customCastles : castles;
                const pendingCastles = currentCastles.filter(c => c.status === 'pending');
                
                if (pendingCastles.length === 0) {
                    endGame(currentCastles);
                    return;
                }

                let spins = 0;
                const maxSpins = 12 + Math.floor(Math.random() * 8); 
                const interval = setInterval(() => {
                    spins++;
                    const randomIdx = Math.floor(Math.random() * pendingCastles.length);
                    setHighlightedCastleId(pendingCastles[randomIdx].id);
                    playInterfaceSound('spin-tick');

                    if (spins >= maxSpins) {
                        clearInterval(interval);
                        const finalCastle = pendingCastles[randomIdx];
                        setActiveCastleId(finalCastle.id);
                        setHighlightedCastleId(finalCastle.id);
                        setGameState('BETTING');
                        playInterfaceSound('lock');
                        setBattleLog("COMMAND: Allocate Troops");
                    }
                }, 80);
            };

            const handleDeploy = () => {
                playInterfaceSound('march');
                setGameState('MARCHING'); 
                const botBid = calculateBotBid();
                setBattleLog("TROOPS DEPLOYED. MARCHING...");
                setTimeout(() => { resolveBattle(botBid); }, 1500);
            };

            const resolveBattle = (botBid) => {
                const newUserTroops = userTroops - currentBid;
                const newBotTroops = botTroops - botBid;
                setUserTroops(newUserTroops);
                setBotTroops(newBotTroops);

                let result = 'tie';
                if (currentBid > botBid) result = 'user';
                if (botBid > currentBid) result = 'bot';

                setCastles(prevCastles => {
                    const updated = prevCastles.map(c => 
                        c.id === activeCastleId 
                        ? { ...c, status: result, userBid: currentBid, botBid: botBid }
                        : c
                    );
                    
                    const dialogue = getRandomDialogue(result);
                    setBattleLog(`"${dialogue}"`);
                    speakText(dialogue, difficulty, voiceBank);

                    if (result === 'user') playInterfaceSound('win');
                    else if (result === 'bot') playInterfaceSound('lose');
                    else playInterfaceSound('clash');
                    
                    playInterfaceSound('clash');
                    setGameState('REVEAL');

                    const isGameOver = updated.every(c => c.status !== 'pending');

                    setTimeout(() => {
                        if (isGameOver) {
                            endGame(updated);
                        } else {
                            setActiveCastleId(null);
                            startRound(updated); 
                        }
                    }, 3000);

                    return updated;
                });
            };

            const endGame = (finalCastles = castles) => {
                setGameState('END');
                setHighlightedCastleId(null);
                setActiveCastleId(null);
                
                // CALCULATE WINNER
                const userScore = finalCastles.filter(c => c.status === 'user').length;
                const botScore = finalCastles.filter(c => c.status === 'bot').length;
                
                let tagline = "";
                const persona = PERSONAS[difficulty];

                if (userScore > botScore) {
                     tagline = persona.taglines.userWin;
                } else if (botScore > userScore) {
                     tagline = persona.taglines.botWin;
                } else {
                     tagline = persona.taglines.tie;
                }

                setBattleLog(`"${tagline}"`);
                speakText(tagline, difficulty, voiceBank);
            };

            const getScore = (who) => castles.filter(c => c.status === who).length;

            // --- STYLES ---
            const bgClass = isDark 
                ? "bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-slate-900 via-slate-950 to-black text-slate-200" 
                : "bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-blue-50 via-slate-100 to-slate-200 text-slate-800";
            
            const cardBg = isDark ? "bg-slate-900/80 border-slate-800" : "bg-white/80 border-white";
            const textPrimary = isDark ? "text-white" : "text-slate-900";
            const textSecondary = isDark ? "text-slate-500" : "text-slate-500";
            const panelShadow = isDark ? "shadow-2xl" : "shadow-xl shadow-slate-300/50";

            const CurrentPersonaIcon = PERSONAS[difficulty].icon;

            // --- RENDER SETUP ---
            if (gameState === 'SETUP') {
                return (
                    <div className={`min-h-screen flex flex-col items-center justify-center p-6 transition-colors duration-500 ${bgClass}`}>
                        <button onClick={toggleTheme} className={`absolute top-6 right-16 p-3 rounded-full transition-all ${isDark ? 'bg-slate-800 hover:bg-slate-700 text-yellow-400' : 'bg-white hover:bg-slate-50 text-slate-600 shadow-md'}`}>
                            {isDark ? <IconSun className="w-6 h-6" /> : <IconMoon className="w-6 h-6" />}
                        </button>
                        
                        <button onClick={() => setShowDetails(true)} className={`absolute top-6 right-4 p-3 rounded-full transition-all ${isDark ? 'bg-slate-800 hover:bg-slate-700 text-blue-400' : 'bg-white hover:bg-slate-50 text-blue-600 shadow-md'}`}>
                            <IconInfo className="w-6 h-6" />
                        </button>

                        {showDetails && <DetailsModal onClose={() => setShowDetails(false)} isDark={isDark} />}

                        <motion.div initial={{ opacity: 0, scale: 0.9 }} animate={{ opacity: 1, scale: 1 }} className={`w-full max-w-lg p-8 rounded-2xl backdrop-blur-md border ${isDark ? 'bg-slate-900 border-slate-800' : 'bg-white/90 border-white shadow-xl shadow-blue-100'}`}>
                            <div className="flex items-center justify-center gap-3 mb-8">
                                <IconSword className="w-8 h-8 text-blue-500" />
                                <h1 className={`text-3xl font-black tracking-tighter ${textPrimary}`}>FRONTLINE COMMANDER</h1>
                            </div>

                            <ConfigControl label="TOTAL TROOPS" value={configTroops} min={50} max={500} step={10} onChange={setConfigTroops} isDark={isDark} />
                            <ConfigControl label="BATTLEFIELDS" value={configCastles} min={3} max={9} step={2} onChange={setConfigCastles} isDark={isDark} />

                            <div className="mb-10">
                                <label className={`text-sm font-bold ${textSecondary} block mb-3`}>CHOOSE YOUR OPPONENT</label>
                                <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                                    {Object.entries(PERSONAS).map(([key, persona]) => (
                                        <button key={key} onClick={() => selectDifficulty(key)} className={`flex flex-col items-center py-4 px-2 rounded-xl transition-all border ${difficulty === key ? (key === 'TYRANT' || key === 'HARD' ? 'bg-red-500/10 border-red-500 text-red-500 shadow-[0_0_15px_rgba(239,68,68,0.3)]' : 'bg-blue-500/10 border-blue-500 text-blue-500 shadow-[0_0_15px_rgba(59,130,246,0.3)]') : (isDark ? 'bg-slate-800 border-slate-700 text-slate-500 hover:bg-slate-750' : 'bg-white border-slate-200 text-slate-400 hover:bg-slate-50')}`}>
                                            <persona.icon className="w-8 h-8 mb-2" />
                                            <span className="text-xs font-black tracking-wider text-center">{persona.name}</span>
                                        </button>
                                    ))}
                                </div>
                                <div className={`mt-3 text-xs text-center font-medium h-4 ${isDark ? 'text-slate-400' : 'text-slate-600'}`}>{PERSONAS[difficulty].description}</div>
                            </div>

                            <button onClick={startGame} className={`w-full py-4 font-black rounded-xl shadow-lg transition-transform transform hover:scale-[1.02] tracking-widest text-lg ${isDark ? 'bg-white hover:bg-blue-50 text-slate-900' : 'bg-slate-900 hover:bg-slate-800 text-white'}`}>DEPLOY TO BATTLE</button>
                        </motion.div>
                    </div>
                );
            }

            // --- RENDER GAME ---
            return (
                <div className={`min-h-screen flex flex-col items-center justify-center p-4 relative overflow-hidden transition-colors duration-500 ${bgClass}`}>
                    <button onClick={toggleTheme} className={`absolute top-6 right-16 z-50 p-3 rounded-full transition-all ${isDark ? 'bg-slate-800 hover:bg-slate-700 text-yellow-400' : 'bg-white hover:bg-slate-50 text-slate-600 shadow-md'}`}>
                        {isDark ? <IconSun className="w-6 h-6" /> : <IconMoon className="w-6 h-6" />}
                    </button>
                    
                    <button onClick={() => setShowDetails(true)} className={`absolute top-6 right-4 z-50 p-3 rounded-full transition-all ${isDark ? 'bg-slate-800 hover:bg-slate-700 text-blue-400' : 'bg-white hover:bg-slate-50 text-blue-600 shadow-md'}`}>
                        <IconInfo className="w-6 h-6" />
                    </button>

                    {showDetails && <DetailsModal onClose={() => setShowDetails(false)} isDark={isDark} />}

                    <motion.div initial={{ y: -50, opacity: 0 }} animate={{ y: 0, opacity: 1 }} className={`relative z-20 w-full max-w-3xl grid grid-cols-3 gap-4 mb-8 p-6 backdrop-blur-md rounded-2xl border ${cardBg} ${panelShadow}`}>
                        <div className={`flex flex-col items-center border-r ${isDark ? 'border-slate-700' : 'border-slate-200'}`}>
                            <div className="flex items-center gap-2 text-blue-500 mb-1"><IconUser className="w-5 h-5" /><span className="text-xs font-bold tracking-[0.2em]">COMMANDER</span></div>
                            <div className={`text-5xl font-black tabular-nums tracking-tighter ${textPrimary}`}>{userTroops}</div>
                            <div className={`text-[10px] uppercase mt-1 ${textSecondary}`}>Reserves</div>
                        </div>

                        <div className="flex flex-col items-center justify-center text-center">
                            <div className={`flex items-center gap-4 text-3xl font-black ${isDark ? 'text-slate-700' : 'text-slate-300'}`}>
                                <span className={getScore('user') > getScore('bot') ? 'text-blue-500' : ''}>{getScore('user')}</span>
                                <span className={isDark ? 'text-slate-800' : 'text-slate-300'}>-</span>
                                <span className={getScore('bot') > getScore('user') ? 'text-red-500' : ''}>{getScore('bot')}</span>
                            </div>
                            <div className={`text-xs mt-3 font-mono ${textSecondary} px-2 h-8`}>
                                {/* TYPEWRITER LOG HERE */}
                                <TypewriterLog text={battleLog} difficulty={difficulty} />
                            </div>
                        </div>

                        <div className={`flex flex-col items-center border-l ${isDark ? 'border-slate-700' : 'border-slate-200'}`}>
                            <div className="flex items-center gap-2 text-red-500 mb-1"><span className="text-xs font-bold tracking-[0.2em]">{PERSONAS[difficulty].name}</span><CurrentPersonaIcon className="w-5 h-5" /></div>
                            <div className={`text-5xl font-black tabular-nums tracking-tighter ${textPrimary}`}>{gameState === 'END' ? 0 : '??'}</div>
                             <div className={`text-[10px] uppercase mt-1 ${textSecondary}`}>{difficulty === 'HARD' || difficulty === 'TYRANT' ? '???' : `Est. ${botTroops}`}</div>
                        </div>
                    </motion.div>

                    <div className="relative z-10 flex flex-wrap justify-center gap-6 mb-12 w-full max-w-5xl px-4">
                        <AnimatePresence>
                            {castles.map((castle) => (
                                <CastleCard key={castle.id} data={castle} isHighlighted={highlightedCastleId === castle.id} isActive={activeCastleId === castle.id} gameState={gameState} userTroops={userTroops} currentBid={currentBid} isDark={isDark} />
                            ))}
                        </AnimatePresence>
                    </div>

                    <div className="w-full max-w-xl min-h-[160px] flex flex-col items-center justify-center relative z-20">
                        {gameState === 'START' && (
                            <motion.button whileHover={{ scale: 1.05 }} whileTap={{ scale: 0.95 }} onClick={() => startRound(castles)} className={`px-10 py-4 text-white font-bold rounded-lg shadow-lg transition-all tracking-widest border ${isDark ? 'bg-blue-600 hover:bg-blue-500 border-blue-400 shadow-[0_0_30px_rgba(37,99,235,0.4)]' : 'bg-slate-900 hover:bg-slate-800 border-slate-700 shadow-xl'}`}>INITIATE CAMPAIGN</motion.button>
                        )}

                        {gameState === 'SPINNING' && (
                            <div className={`flex items-center gap-3 font-mono animate-pulse ${isDark ? 'text-yellow-400' : 'text-yellow-600'}`}><span className={`h-2 w-2 rounded-full ${isDark ? 'bg-yellow-400' : 'bg-yellow-600'}`}></span>SCANNING BATTLEFIELDS...</div>
                        )}

                        {(gameState === 'MARCHING') && (
                             <div className="flex items-center gap-3 text-blue-500 font-mono animate-pulse"><span className="h-2 w-2 bg-blue-500 rounded-full"></span>DEPLOYING FORCES...</div>
                        )}

                        {gameState === 'BETTING' && (
                            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} className={`w-full backdrop-blur p-6 rounded-2xl border ${panelShadow} ${cardBg}`}>
                                <div className="flex justify-between mb-4 text-sm font-medium">
                                    <span className={`font-mono ${textSecondary}`}>DEPLOYMENT STRENGTH</span>
                                    <div className="flex items-center gap-2">
                                        <span className={`text-xl ${textPrimary}`}>{currentBid} <span className={`text-sm ${textSecondary}`}>/ {userTroops}</span></span>
                                        <button 
                                            onClick={() => {
                                                playInterfaceSound('click');
                                                setCurrentBid(userTroops);
                                            }}
                                            className="px-2 py-1 text-xs font-bold bg-red-500/20 text-red-500 border border-red-500/50 rounded hover:bg-red-500/30 transition-colors"
                                        >
                                            ALL IN
                                        </button>
                                    </div>
                                </div>
                                
                                <div className="relative h-6 w-full flex items-center mb-6">
                                    <input type="range" min="0" max={userTroops} value={currentBid} onChange={(e) => setCurrentBid(parseInt(e.target.value))} className="absolute z-30 w-full h-full opacity-0 cursor-pointer" style={{ WebkitAppearance: 'none', appearance: 'none' }} />
                                    <div className={`absolute z-10 w-full h-3 rounded-full border ${isDark ? 'bg-slate-950 border-slate-600' : 'bg-slate-300 border-slate-400'}`}></div>
                                    <div className="absolute z-10 h-3 bg-gradient-to-r from-blue-600 to-cyan-400 rounded-full pointer-events-none transition-all duration-75" style={{ width: `${(currentBid / userTroops) * 100}%` }}></div>
                                    <div className={`absolute z-20 h-6 w-6 bg-white border-2 border-blue-500 rounded-full pointer-events-none transition-all duration-75 ${isDark ? 'shadow-[0_0_10px_rgba(59,130,246,0.5)]' : 'shadow-md'}`} style={{ left: `calc(${(currentBid / userTroops) * 100}% - 12px)` }}></div>
                                </div>
                                <motion.button whileHover={{ scale: 1.02 }} whileTap={{ scale: 0.98 }} onClick={handleDeploy} className={`w-full py-4 text-white font-bold rounded-xl shadow-lg transition-all tracking-widest uppercase text-sm border-t ${isDark ? 'bg-gradient-to-r from-blue-700 to-blue-600 hover:from-blue-600 hover:to-blue-500 border-blue-400' : 'bg-slate-900 hover:bg-slate-800 border-slate-600'}`}>CONFIRM DEPLOYMENT</motion.button>
                            </motion.div>
                        )}

                        {gameState === 'END' && (
                            <motion.div initial={{ scale: 0.8, opacity: 0 }} animate={{ scale: 1, opacity: 1 }} className={`text-center p-8 rounded-2xl border ${panelShadow} ${cardBg}`}>
                                <IconTrophy className={`w-16 h-16 mx-auto mb-4 ${getScore('user') > getScore('bot') ? 'text-yellow-400' : 'text-slate-400'}`} />
                                <h2 className={`text-3xl font-black mb-2 ${textPrimary}`}>{getScore('user') > getScore('bot') ? "VICTORY ACHIEVED" : getScore('user') < getScore('bot') ? "MISSION FAILED" : "DRAW"}</h2>
                                <p className={`mb-6 ${textSecondary}`}>Final Score: <span className="text-blue-500">{getScore('user')}</span> - <span className="text-red-500">{getScore('bot')}</span></p>
                                <div className="flex gap-4 justify-center">
                                    <button onClick={resetToSetup} className={`px-6 py-3 font-bold rounded-lg transition-colors border ${isDark ? 'bg-slate-800 hover:bg-slate-700 text-white border-slate-600' : 'bg-slate-100 hover:bg-slate-200 text-slate-800 border-slate-300'}`}>HOME</button>
                                    <button onClick={startGame} className="px-6 py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-lg transition-colors shadow-lg">RETRY</button>
                                </div>
                            </motion.div>
                        )}
                    </div>

                    <div className={`fixed inset-0 pointer-events-none z-0 ${isDark ? 'opacity-20 bg-[url("https://www.transparenttextures.com/patterns/carbon-fibre.png")]' : 'opacity-10 bg-[url("https://www.transparenttextures.com/patterns/graphy.png")]'}`}></div>
                </div>
            );
        };

        const BattleAnimation = ({ result }) => (
            <div className="absolute inset-0 z-50 flex items-center justify-center pointer-events-none">
                <motion.div initial={{ x: -50, y: 50, rotate: -45, opacity: 0 }} animate={{ x: [-50, 0, -100], y: [50, 0, -50], rotate: [-45, 0, -180], opacity: [0, 1, 0], scale: [0.5, 1.5, 2] }} transition={{ duration: 1.5, times: [0, 0.2, 1] }}><IconSword className="w-16 h-16 text-blue-500 fill-blue-500/50" /></motion.div>
                <motion.div initial={{ x: 50, y: 50, rotate: 45, opacity: 0 }} animate={{ x: [50, 0, 100], y: [50, 0, -50], rotate: [45, 0, 180], opacity: [0, 1, 0], scale: [0.5, 1.5, 2] }} transition={{ duration: 1.5, times: [0, 0.2, 1] }}><IconSword className="w-16 h-16 text-red-500 fill-red-500/50" /></motion.div>
                <motion.div initial={{ scale: 0, opacity: 0 }} animate={{ scale: [0, 2, 3], opacity: [0, 1, 0] }} transition={{ delay: 0.2, duration: 0.5 }} className="absolute w-20 h-20 bg-white rounded-full blur-xl" />
            </div>
        );

        const MarchingTroops = ({ isBot }) => {
            const troops = useMemo(() => Array.from({ length: 8 }), []);
            return (
                <div className="absolute inset-0 z-40 overflow-hidden pointer-events-none">
                    {troops.map((_, i) => (
                        <motion.div key={i} initial={{ y: isBot ? -150 : 150, x: (Math.random() * 60) - 30, opacity: 0 }} animate={{ y: 0, opacity: [0, 1, 0], scale: [0.5, 1, 0.5] }} transition={{ duration: 1 + Math.random() * 0.5, delay: Math.random() * 0.5, ease: "easeIn" }} className={`absolute top-1/2 left-1/2 w-2 h-2 rounded-full ${isBot ? 'bg-red-500 shadow-[0_0_5px_red]' : 'bg-blue-500 shadow-[0_0_5px_blue]'}`} />
                    ))}
                </div>
            );
        };

        const CastleCard = ({ data, isHighlighted, isActive, gameState, userTroops, currentBid, isDark }) => {
            let borderColor = isDark ? "border-slate-800" : "border-slate-200";
            let glow = "";
            let iconColor = isDark ? "text-slate-700" : "text-slate-300";
            let bg = isDark ? "bg-slate-900" : "bg-white";
            let scale = 1;
            let opacity = 1;

            if (gameState === 'BETTING' && !isActive && data.status === 'pending') {
                const remainingAfterBid = userTroops - currentBid;
                if (remainingAfterBid < 10) { opacity = 0.3; scale = 0.9; iconColor = "text-red-900"; } 
                else if (remainingAfterBid < 30) { opacity = 0.6; scale = 0.95; }
            }

            if (isHighlighted && gameState === 'SPINNING') {
                borderColor = isDark ? "border-yellow-500" : "border-yellow-400";
                glow = isDark ? "shadow-[0_0_20px_rgba(234,179,8,0.4)]" : "shadow-[0_0_20px_rgba(234,179,8,0.6)]";
                iconColor = isDark ? "text-yellow-500" : "text-yellow-600";
                bg = isDark ? "bg-slate-800" : "bg-yellow-50";
                scale = 1.05;
            }

            if (isActive && (gameState === 'BETTING' || gameState === 'MARCHING' || gameState === 'REVEAL')) {
                borderColor = "border-blue-500";
                glow = isDark ? "shadow-[0_0_30px_rgba(59,130,246,0.3)]" : "shadow-[0_0_30px_rgba(59,130,246,0.4)]";
                iconColor = "text-blue-500";
                bg = isDark ? "bg-slate-800" : "bg-blue-50";
                scale = 1.15;
            }

            if (data.status === 'user') { borderColor = "border-blue-500/50"; iconColor = "text-blue-500"; bg = isDark ? "bg-blue-950/40" : "bg-blue-100"; }
            else if (data.status === 'bot') { borderColor = "border-red-500/50"; iconColor = "text-red-500"; bg = isDark ? "bg-red-950/40" : "bg-red-100"; }
            else if (data.status === 'tie') { borderColor = isDark ? "border-slate-600" : "border-slate-300"; iconColor = "text-slate-400"; opacity = 0.7; }

            return (
                <motion.div className={`relative w-32 h-48 rounded-xl border-2 ${borderColor} ${bg} ${glow} flex flex-col items-center justify-center transition-all duration-300 overflow-hidden shadow-lg`} style={{ opacity, scale }} layout>
                    <AnimatePresence>{isActive && gameState === 'MARCHING' && (<><MarchingTroops isBot={false} /><MarchingTroops isBot={true} /></>)}{isActive && gameState === 'REVEAL' && (<BattleAnimation result={data.status} />)}</AnimatePresence>
                    <AnimatePresence>{gameState === 'REVEAL' && isActive && (<motion.div initial={{ opacity: 0, backdropFilter: "blur(0px)" }} animate={{ opacity: 1, backdropFilter: "blur(8px)" }} exit={{ opacity: 0 }} className={`absolute inset-0 flex flex-col items-center justify-center rounded-lg z-30 ${isDark ? 'bg-slate-950/70' : 'bg-white/70'}`}><div className="text-blue-500 text-2xl font-black drop-shadow-md">{data.userBid}</div><div className={`h-px w-12 my-2 ${isDark ? 'bg-slate-500' : 'bg-slate-300'}`}></div><div className="text-red-500 text-2xl font-black drop-shadow-md">{data.botBid}</div></motion.div>)}</AnimatePresence>
                    <div className="mb-6 relative z-10">{data.status === 'user' ? <IconShield className={`w-12 h-12 ${iconColor}`} /> : data.status === 'bot' ? <IconSword className={`w-12 h-12 ${iconColor}`} /> : <DetailedCastle className={`w-16 h-16 ${iconColor}`} />}</div>
                    <div className="absolute bottom-4 flex flex-col items-center z-10"><div className={`w-2 h-2 rounded-full shadow-lg ${data.status === 'pending' ? (isDark ? 'bg-slate-700' : 'bg-slate-300') : data.status === 'user' ? 'bg-blue-500 shadow-blue-500/50' : data.status === 'bot' ? 'bg-red-500 shadow-red-500/50' : 'bg-slate-500'}`}></div></div>
                    {data.status === 'pending' && !isActive && (<div className={`absolute inset-0 border-2 opacity-0 hover:opacity-100 rounded-xl transition-opacity pointer-events-none ${isDark ? 'border-slate-500' : 'border-slate-400'}`}></div>)}
                </motion.div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<FrontlineCommander />);
    </script>
</body>
</html>
